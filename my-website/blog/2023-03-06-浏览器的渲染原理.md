---
slug: 浏览器的渲染原理
title: 浏览器的渲染原理
authors: [Lvxl]
tags: [浏览器的渲染原理]
---

### 浏览器是如何渲染页面的
当浏览器的网络线程收到HTML文档后,会产生一个渲染任务,并将其传递给渲染主线程的消息队列.

在事件循环的机制作用下, 渲染主线程去取出消息队列中的渲染任务, 开启渲染流程

整个渲染流程的阶段分为: HTML解析, 样式计算, 布局, 分层, 绘制, 分块, 光栅化, 画

1. pares Html 生成 dom树 css object model
    - 渲染主线程解析到link位置, 此时外部的css文件还没有下载解析好,主线程不会等待,继续解析HTML,因为下载和解析css工作是在预解析线程中完成的,所以不会阻塞html的解析
    - 渲染主线程遇到js事会暂停一切行为, 等待下载执行完后才能继续执行, 因为js代码可以随意修改html里面的内容

2. 样式计算
    - 会将预设值变成绝对值, 例如red变成rgb(255,0,0), 相对单位会变成绝对单位 em变 px
3. 布局
    - display:none的节点没有几何信息,因此不会生成到布局树,比如使用了伪元素,虽然dom树不存在节点,但是它拥有几何信息,所以会生成到布局树中
4. 分层
    - 分层的好处在于,将来某一个层改变后,会对改层进行后续处理, 从而提升效率
    - 滚动条, 堆叠上下文, transform, opacity等样式都会或多或少影响分层结果, 也可以通过will-channge属性更大程度影响分层结果
5. 绘制
    - 分层绘制
    - 渲染主线程工作到此为止,剩下交给其他线程处理
6. 分块
    - 合成线程-属于渲染进程
7. 光栅化
    - 是将每个块变成位图
    - 此过程会用到GPU加速
    - 优先处理靠近视口的块
8. 画
    - 合成线程拿到每个层,每个块的位图, 生成一个个指引信息
    - 指引会标识出每个位图应该画到屏幕的那个位置, 以及旋转,缩放等变形,
    - 变形在合成线程中, 与主线程无关, 这就是transform效率高的本质原因
    - 合成线程交给GPU

### 什么是 reflow (回流)

### 什么是 replant (重绘)