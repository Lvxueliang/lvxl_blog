# JAVASCRIPT

### js事件循环机制 (Event Loop)
js是一门单线程语言,异步操作都是放到事件循环队列里面的,等待主执行栈来执行的,并没有专门的异步执行线程
1. 同步和异步
    - **同步**:js代码是自上而下执行的,在主线程中立即执行的就是同步任务,例如: 简单的逻辑操作及函数
    - **异步**:而有些任务耗时任务不会立刻执行,会放到异步队列中, 例如: ajax, promise, 计时器等等

2. 事件循环: 等待主线程中任务全部完成后, 再把异步队列中的任务放到主程序中运行, 这样反复循环

3. 宏任务和微任务
    - **宏任务(Marco Task)** : 主要包含 setTimeout, setInterval, script(整体代码), ui事件交互, setImmediate(node.js环境)
    - **微任务(Micro Task)** : 主要包含 Promise.then() catch(), MutationObserver, process.nextTick(node.js环境)

4. 最新规范
    浏览器的`渲染进程`:
    JS是⼀⻔单线程的语⾔，这是因为它运⾏在浏览器的渲染主线程中，⽽渲染主线程只有⼀个。

    ⽽渲染主线程承担着诸多的⼯作，渲染⻚⾯、执⾏ JS 都在其中运⾏。

    如果使⽤同步的⽅式，就极有可能导致主线程产⽣阻塞，从⽽导致消息队列

    中的很多其他任务⽆法得到执⾏。这样⼀来，⼀⽅⾯会导致繁忙的主线程⽩⽩的消耗时间，另⼀⽅⾯导致⻚⾯⽆法及时更新，给⽤户造成卡死现象。

    所以浏览器采⽤异步的⽅式来避免。具体做法是当某些任务发⽣时，⽐如计时器、⽹络、事件监听，主线程将任务交给其他线程去处理，⾃身⽴即结束任务的执⾏，转⽽执⾏后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加⼊到消息队列的末尾排队，等待主线程调度执⾏。

    在这种异步模式下，浏览器永不阻塞，从⽽最⼤限度的保证了单线程的流畅
    运⾏。

执行栈 ---> 微任务 ---> 宏任务

```js
console.log(1)
setTimeout(() => {
    console.log(2)
},0)
const p = new Promise((resolve, reject) => {
    console.log(3)
    resolve(1000)
    console.log(4)
})
p.then(data => {
    console.log(data)
})
console.log(5)
 
//执行栈开始:没有微任务, 执行宏任务 --> 读取上面代码整块内容 script
//sciprt 执行栈: 1 -> settimeout 放到宏任务队列 -> new pormise 输出3,4 -> p.then() 放到微任务 -> 5
// 这时执行结果 1 3 4 5
// 将微任务队列放到执行栈 p.then 输出 1000
// 这时执行结果 1 3 4 5  1000
// 将宏任务队列放到执行栈 settimeout 输出 2
// 结果 : 1 3 4 5 1000 2   
```
script start 
async1 start
async 2
1end
settimeout

### 事件委托 DOM事件流
**dom事件流**: 元素事件响应在dom树中是从顶层的window开始‘流向’目标元素,然后又从 目标元素‘流向’顶层的window

通常我们将这种事件流向氛围三个阶段:

 **捕获阶段**: 是指事件响应从外层window开始,逐级向内层前进,直到目标元素, 在该阶段,不会处理响应元素的注册冒泡事件

 **目标阶段**: 是指触发事件的最底层的元素

 **冒泡阶段**: 与捕获相反, 是从最底层开始一层一层往外传递到window最外层

```js
    element.addEventListener(监听事件类型, 事件回调函数, 默认 false: 冒泡,捕获:true)
```
**事件冒泡：**
JS中当出发某些具有冒泡性质的事件是，首先在触发元素寻找是否有相应的注册事件，如果没有再继续向上级父元素寻找是否有相应的注册事件作出相应，这就是事件冒泡。

**事件委托：**
利用事件冒泡的特性，将本应该注册在子元素上的处理事件注册在父元素上，这样点击子元素时发现其本身没有相应事件就到父元素上寻找作出相应。

这样做的优势有：
1. 减少DOM操作，提高性能。
2. 随时可以添加子元素，添加的子元素会自动有相应的处理事件。


### 原型和原型链
**原型** : 每个函数都有prototype属性 称之为原型, 因为这个属性值是一个对象, 也称为原型对象

- 可以存放一些方法和属性
- 可以实现继承

**原型链** : 每个对象都有__proto__指向了这个对象原型,原型也是对象, 也有__proto__属性, 指向了原型对象的原型对象,这样一层一层的形成了连式结构,称为原型链, 最顶层找不到了返回null

### 闭包
函数内部访问了函数外层的引用, 就会产生闭包
- 变量私有化, 防止全局变量被污染